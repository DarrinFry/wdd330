<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 1 Notes</title>
    <link rel="stylesheet" href="../css/style.css"/>
</head>
<body>
    <h1>Darrin Fry WDD 330 Portfolio</h1>
    <a href="../index.html">Go Home</a>
    <h2>Week 4</h2>

    <div>
        <h3>Notes from reading:</h3>
        <ul>
            <li>Forms are made up of a <form> element that contains form controls such as input fields, select menus and buttons. These input fields can be populated with information that is processed once the form has been submitted.</li>
            <li>Each form control has an initial value that can be specified in the HTML code. This value can be changed by a user entering information or interacting with the form's interface (such as using a slider to increase or decrease a value). The value can also be changed dynamically using JavaScript.</li>
            <li>The legacy DOM had a useful property called document.forms that returns an HTML collection of all the forms in the document in the order they appear in the markup. </li>
            <li>square bracket notation can be used (this is also required if the form's name attribute contains any invalid characters, such as spaces or dashes):  const form = document.forms['search'];</li>
            <li>The form.reset() method will reset all the form controls back to their initial values specified in the HTML.</li>
            <li>Reset buttons are generally considered poor for usability, as they are too easy to click and then wipe out all the data that's been entered. So think very carefully before using one in a form.</li>
            <li>The focus event occurs when an element is focused on. In the case of an input element, this is when the cursor is placed inside the element (either by clicking or tapping on it or navigating to it using the keyboard).</li>
            <li>The blur event occurs when the user moves the focus away from the form element.</li>
            <li>The change event occurs when the user moves the focus away from the form element after changing it</li>
            <li>Possibly the most important form event is the submit event, occurring when the form is submitted. Usually this will send the content of the form to the server to be processed, but we can use JavaScript to intercept the form before it's sent by adding a submit event listener.</li>
            <li>preventDefault() can be used to prevent a normal action from happening. Useful if testing so it doesn't ry to send the form to the backend.</li>
            <li>The autofocus attribute give focus to this element when a page loads. </li>
            <li>Hidden fields can be created using input fields with type='hidden'. These are not displayed by the browser, but have a 'value' attribute that can contain information that is submitted with the form. They are often used to send information such as settings or information that the user has already provided.</li>
            <li>There are different types of buttons. The default type is 'submit', which is why we didn't have to specify the type in the search example.</li>
            <li>Form validation is the process of checking whether a user has entered the information into a form correctly.</li>
            <li>Validation can occur on the client side using JavaScript, and on the server side. It is advisable to use both client-side and server-side validation. </li>
            <li></li>
            <li>OOP notes taken directly from the Ninja readings.</li>
            <li>Object-oriented programming (OOP) is a way of programming that uses objects that encapsulate their own properties and methods.

            </li>
            <li>The main concepts of OOP are encapsulation, polymorphism and inheritance.

            </li>
            <li>Constructor functions can be used to create instances of objects.

            </li>
            <li>ES6 introduced class declarations that use the class keyword. These can be used in place of constructor functions.

            </li>
            <li>Inside a constructor function or class declaration, the keyword this refers to the object returned by the function.

            </li>
            <li>All instances of a class or constructor function inherit all the properties and methods of its prototype.

            </li>
            <li>The prototype is live, so new properties and methods can be added to existing instances.

            </li>
            <li>The prototype chain is used to find an available method. If an object lacks a method, JavaScript will check whether its prototype has the method. If not, it will check that function’s prototype until it finds the method or reaches the Object constructor function.

            </li>
            <li>Private properties and methods can be created by defining variables using const and defining a function inside a constructor function. These can be made public using getter and setter functions.

            </li>
            <li>Monkey-patching is the process of adding methods to built-in objects by augmenting their prototypes. This should be done with caution as it can cause unexpected behavior in the way built-in objects work.

            </li>
            <li>A mixin method can be used to add properties and methods from other objects without creating an inheritance chain.

            </li>
            <li>Methods can be chained together and called in sequence if they return a reference to this.

            </li>
            <li>Polymorphism allows objects to override shared methods with a more specific implementation.

            </li>
            <li>The value of this is not retained inside nested functions, which can cause errors. This can be worked around by using that = this, using the bind(this) method and using arrow functions.</li>
            <li>Methods can be borrowed from other objects.

            </li>
            <li>Composition over inheritance is a design pattern where objects are composed from 'building-block' objects, rather than inheriting all their properties and methods from a parent class.

            </li>
            <li></li>
            <li>A module is a self-contained piece of code that provides functions and methods that can then be used in other files and by other modules.</li>
            <li>Keeping code modular helps to make it more loosely coupled and interchangeable, meaning you can easily swap one module for another without affecting other parts of a project.</li>
            <li>Two pieces of code are said to be tightly coupled if one relies on the other to run. This often occurs if a piece of code makes hard-coded references to another piece of code, requiring it to be used. </li>
            <li>t is considered good design to keep code as loosely coupled as possible as this allows for the most flexibility</li>
            <li>All code in modules is always in strict mode without the need for 'use strict' and there is no way to opt out of this.</li>
            <li>A module has its own global scope, so any variables created in the top-level of a module can only be accessed within that module.            </li>
            <li>The value of this in the top level of a module is undefined, rather than the global object.            </li>
            <li>You can't use HTML-style comments in modules (although this isn't very common in any JavaScript program these days).            </li>
            <li>A ES6 module file is just a normal JavaScript file, but uses the keyword export to specify any values or functions that are to be made available from the module. This highlights another important fact about modules – not everything in the module needs to be used.</li>
            <li>If there are lots of values and functions that need to be imported, then everything in a module file can be imported using the wildcard symbol * along with a namespace for the imported values and functions using the following notation: import * as stats from './stats.js';</li>
            <li>Default exports refer to a single variable, function or class in a module that can be imported without having to be explicitly named.</li>
            <li>Don't Use More Than One Default Export Having more than one default export will result in a syntax error.</li>
            <li>The alias that is assigned to the imported module does not have to match its name in the actual module.</li>
            <li></li>


        </ul>
    </div>
    <div>
        <h3>Practice:</h3>
        <ul>
            <li><a href="code_ninja_quiz_ninja.html" target="_blank">Code Ninja || Quiz Ninja</a></li>
            <li><a href="coding_practice.html" target="_blank">Week 4 Code Practice</a></li>
            <li><a href="team_assignement.html" target="_blank">"Team assignment"</a></li>

        </ul>
    </div>
    <div>
        <h3>Questions:</h3>
        <ol>
            <li></li>
        </ol>
    </div>
    
</body>
</html>

